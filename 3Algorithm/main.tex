\chapter{
Algorithm \draftnote{blue}{(change name)}{}
\draftnote{blue}{ V1}{}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation}
\whendraft{
	\begin{enumerate}
		\item Why create the algorithm ?
		      \begin{itemize}
			      \item We wanted a way to explore structures.
		      \end{itemize}

	\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description [/preliminaries?]}
\whendraft{
	\textbf{Include in algorithm description:}
	\begin{enumerate}
        \item What each of the objects in the algorithm (e.g., $L$) are during the algorithm (e.g., $L \subseteq \hat{A}^{*}$).
        \item What each of the objects are when the algorithm terminates.
		\item Make up of $\mathcal{E}$.
		\item We store actions as their unique sequences of minimum actions.
		\item All we need from $\mathscr{W}$ is the set $W$ of world states and the map $\hat{*}: \hat{A} \times W \to W$.
		      We treat $\hat{*}$ as a part of $\mathscr{W}$.
		\item How we use the $\operatorname{Combine}$ operator to evaluate $\circ$.
		\item What each of elements of $\mathcal{E}$ are at the termination of the algorithm.
		\item $\operatorname{Seq} : \hat{A}^* \to (\hat{A})^n, \quad \operatorname{Seq}(a) = (\hat{a}_{n}, \hat{a}_{n-1}, \dots, \hat{a}_{1})$
		\item Explain how assignment to $\mathcal{E}$ works - assignment occurs for each of the constituents of $\mathcal{E}$.
		\item Mention that the only bit of information needed from $\mathscr{W}$ is the mapping: $\hat{*}: \hat{A} \times W \to W$ that takes a minimum action and applies it to a world state.


	\begin{enumerate}
		\item Change name of `states Cayley table' and `actions Cayley table` ?
		      \begin{itemize}
			      \item Cayley table is already a thing.
		      \end{itemize}
	\end{enumerate}

    \item ``transformations generated by $\hat{A}$under composition form a sub (semi-)monoid of the full transformation monoid on $W^{\bot}$''.

    \item Can represent each $f_{a}$ by a tuple $(f_{a}(w_{0}), f_{a}(w_{1}), \cdots , f_{a}(w_{n}), f_{a}(\bot))$.

    \item "Cayley tables can be used to characterize the operation of any finite magma"
\end{enumerate}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The initial}


The definition of $\sim$ is ...





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical preliminaries}
\whendraft{
	\begin{enumerate}
		\item Definition of Cayley table. - put this in motivation section ?
	\end{enumerate}
}


\paragraph{What is an actions Cayley table?}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Design decisions}

\paragraph{Problem:}
[?] Assessing equality between two actions.
\\\textit{Solution:}


\paragraph{Problem:}
Calculating the result of the $\circ$ operator.
\\\textit{Solution:}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Problem:}
How do we know if the algebra produced is complete?
\\\textit{Solution:}
\begin{itemize}
	\item
\end{itemize}


\paragraph{Problem:}
Dealing with undefined actions.
\\\textit{Solution:}
\begin{itemize}
	\item Describe how we implemented the undefined state.
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pseudocode}
\whendraft{
	\noindent\rule{\textwidth}{1mm}
	\textbf{To do:}
	\begin{enumerate}
		\item [visual] Span algorithms across entire page.
	\end{enumerate}
	\noindent\rule{\textwidth}{1mm}
}


\begin{table*}[htbp]
  \begin{fullwidth}
    \centering
    \begin{tabularx}{\linewidth}{lX}
      \toprule
      \textbf{Symbol}                    & \textbf{Description} \\
      \midrule
      $\hat{A}$                          & The set of minimum actions of the agent. Elements of $\hat{A}$ are given a $\hat{\ }$. \\
      $\mathscr{W} = (W, \; \hat{\ast})$ & The world characterised by a set $W$ of world states and a minimum action effect map $\hat{\ast}$. \\
      $W$                                & The set of world states. \\
      $\hat{\ast}$                       & The minimum effect map $\hat{A} \times W \to W$ that sends a minimum action-world state pair to the resultant world state after the agent performs that minimum action in the world state. \\
      $L$                                & The set of equivalence class labels. \\
      $E$                                & The set of processed elements... \\
      $\pi$                              & A map $E \to L$ ... \\
      $\mathcal{E} = (L, \; E, \; \pi)$  & The equivalence classes. \\
      $\mathcal{T}$                      & A set of functions $f_{a}: W \to W$... \\
      $\rho$                             & A map $L \to \mathcal{T}$ ... \\
      $\hat{A}/\sim$                     & The set of minimum actions that are distinct under $\sim$. \\
      $n$                                & Counter that represents the length ... \\
      $N_{L}$                            & The number of new equivalence class labelling elements ... \\
      $A_{C}$                            & The set of candidates ... \\
      $\mathcal{L}_{n}(L)$               & A filtering map $L \to \{ l \in L \mid |l| = n \}$... \\
      $\operatorname{Combine}$           & The combine operator ... \\
      $T_{A}$                            & The Cayley table. \\
      \bottomrule
    \end{tabularx}
    \caption{Key for pseudocode.}
  \end{fullwidth}
\end{table*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generating the equivalence classes}

\begin{algorithm}
	\caption{
		Generate the equivalence classes $\mathcal{E} = (L, \; E, \; \pi: E \to L)$ for $\sim$ and the set of action functions $\mathcal{T} = \{f_{l}: W \to W\}$ for a world $\mathscr{W} = (W, \; \hat{\ast})$ that is characterised by a set $W$ of world states and a minimum action effect map $\hat{\ast}$.
	}
        \label{alg:GenerateEquivClasses}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{GenerateEquivClasses}{$\hat{A}$, \; $\mathscr{W}$}
		\Statex \Comment{Initialise equivalence classes object $\mathcal{E}$.}
		\State $L \gets \emptyset$
		\State $E \gets \emptyset$
		\State $\pi \gets (\emptyset \to \emptyset)$
		\State $\mathcal{E} \gets (L, \; E, \; \pi)$.

		\Statex \Comment{Initialise $\mathcal{T}$ and $\rho$}
		\State $\mathcal{T} \gets \emptyset$
		\State $\rho: \gets (\emptyset \to \emptyset)$

		\Statex \Comment{Find distinct minimum actions.}
		\For{\textbf{each} $\hat{a} \in \hat{A}$}
		\State $(\mathcal{E}, \; \mathcal{T}, \; \rho) \gets$ \Call{ProcessCandidate}{$\hat{a}$, \; $\mathcal{T}$, \; $\rho$, \; $\mathcal{E}$, \; $\mathscr{W}$}
		\EndFor
		\State $\hat{A}/\sim \; \gets L$

		\Statex \Comment{Iteratively create candidate actions sequences for equivalence class labelling elements then check if they are successful candidates.}
		\State $n \gets 0$
		\State $N_{L} \gets 0$
		\Statex \Comment{If no new labelling actions found in a set of candidate elements, then halt the algorithm.}
		\While{$N_{L} \neq |L|$}
		\State $n \gets n + 1$
		\State $N_{L} \gets |L|$
		\State $A_{C} \gets \Call{GenerateCandidates}{\mathcal{L}_{n}(L), \;  \hat{A}/\sim}$

		\For{\textbf{each} $a_{C} \in A_{C}$}
		\State $(\mathcal{E}, \; \mathcal{T}, \; \rho) \gets$ \Call{ProcessCandidate}{$a_{C}$, \; $\mathcal{T}$, \; $\rho$, \; $\mathcal{E}$, \; $\mathscr{W}$}
		\EndFor
		\EndWhile
		\State \Return $\mathcal{E}, \; \mathcal{T}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{
		Generate new action sequences that are candidates for equivalence class labelling elements.
	}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{GenerateCandidates}{$L$, \;  $\hat{A}/\sim$}
		\State $A_{C} \gets \emptyset$
		\ForAll{$(l, \; \hat{a}) \in L \times \hat{A}/\sim$}
		\State $a' = \operatorname{Combine}(\hat{a}, \; l)$
		\State $A_{C} \gets A_{C} \cup \{a'\}$
		\EndFor
		\State \Return $A_{C}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{
		Process a candidate $a_{C}$ for being an equivalence class labelling element.
		If $a_{C}$ is a successful candidate, then create a new equivalence classes labelled by $a_{C}$.
		If $a_{C}$ is found to be in another equivalence class then add it to that equivalence class.
	}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{ProcessCandidate}{$a_{C}$, \; $\mathcal{T}$, \; $\rho$, \; $\mathcal{E}$, \; $\mathscr{W}$}
		\State $f_{a_{C}} = \Call{ComputeActionFunction}{a_{C}, \; \mathscr{W}}$

		\If{$f_{a_{C}} \in \mathcal{T}$}
		\Statex \Comment{Add $a_{C}$ to equivalence class in $\mathcal{E}$ with class label that has the same action function $f_{a_{C}}$.}
		\State $\mathcal{E} \gets (\; L, \; E \cup \{a_{C}\}, \; \pi \cup \pi' \;)$, where $\pi': \{a_{C}\} \to L$ such that $\pi'(a_{C}) = \rho^{-1}(f_{a_{C}})$.
		\Else
		\Statex \Comment{Create new equivalence class in $\mathcal{E}$ labelled by $a_{C}$.}
		\State $\mathcal{E}' \gets (\; L \cup \{a_{C}\}, \; E \cup \{a_{C}\}, \; \pi \cup \pi' \;)$, where $\pi': \{a_{C}\} \to \{a_{C}\}$ such that $\pi'(a_{C}) = a_{C}$.

		\Statex \Comment{Add $f_{a_{C}}$ to $\mathcal{T}$.}
		\State $\mathcal{T}' \gets \mathcal{T} \cup \{f_{a_{C}}\}$

		\Statex \Comment{Update $\rho$ to send $a_{C}$ to $f_{a_{C}}$.}
		\State $\rho' \gets \rho \cup \rho''$ where $\rho'': \{a_{C}\} \to \{f_{a_{C}}\}$ such that $\rho''(a_{C}) = f_{a_{C}}$
		\EndIf
		\State \Return $(\mathcal{E}', \; \mathcal{T}', \; \rho')$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]
	\caption{Compute the action function $f_{a}: W \to W$ that sends $w \mapsto a \ast w$.}
        \label{alg:ComputeActionFunction}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{ComputeActionFunction}{$a$, \; $\mathscr{W}$}
		\State $f_{a} \gets (\emptyset \to \emptyset)$
		\ForAll{$w \in W$}
		\State $w_{a} \gets$ \Call{GenerateActionOutcome}{$a$, \; $w$, \; $\hat{\ast}$}
		\State $f_{a} \gets f_{a} \cup f_{a}'$ where $f_{a}': \{w\} \to \{w_{a}\}$ such that $f_{a}'(w) = w_{a}$
		\EndFor
		\State \Return $f_{a}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{
		Generate the outcome state of a world $\mathscr{W}$ when an action sequence $a$ is applied to the world in an initial state $w$.
	}
	\label{alg:GenerateActionOutcome}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{GenerateActionOutcome}{$a$, \; $w$, \; $\hat{\ast}$}
		\State $w_{a} \gets w$
		\For{$i \gets 1, \; \dots \;, \; n$}
		\State $w_{a} \gets \hat{a}_{i} \; \hat{\ast} \; w_{a}$ where $\operatorname{Seq}(a) = (\hat{a}_n, \; \hat{a}_{n-1}, \; \dots \;, \; \hat{a}_1)$
		\EndFor
		\State \Return $w_{a}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generating the Cayley table}

\begin{algorithm}[H]
	\caption{
		Generate the Cayley table $T_{A}$
	}
        \label{alg:GenerateCayley}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{GenerateCayley}{$\mathcal{E}$}
		\State $T_{A} \gets$ Empty $|L| \times |L|$ table with rows and columns labelled by the elements of $L$.
		\Statex \Comment{Fill actions Cayley table.}
		\For{\textbf{each} $l_{row} \in L$}
		\For{\textbf{each} $l_{col} \in L$}
		\Statex \Comment{Get action function for the combined element.}
		\State $f_{(l_{row} \; \circ \; l_{col})} \gets$ \Call{ComputeCompositionActionFunction}{$l_{row}$, \; $l_{col}$, \; $\mathcal{T}$, \; $\rho$}
		\State $l \gets \rho^{-1}(f_{(l_{row} \; \circ \; l_{col})})$
		\State $T_{A}[l_{row}][l_{col}] \gets l$

		\whendraft{
			\Statex \Comment{TODO: Add $a$ to the equivalence class as $\operatorname{Combine}(l_{row}, l_{col})$?}
			\Statex \Comment{TODO: Include equivalence class check before generating the combined action function ?}
		}

		\EndFor
		\EndFor

		\State \Return $T_{A}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{
		Compute the action function for the combination $l_{L} \circ l_{R}$ of two actions by combining their action functions.
	}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{ComputeCompositionActionFunction}{$l_{L}$, \; $l_{R}$, \; $\mathcal{T}$, \; $\rho$}
		\Statex \Comment{Get action functions for $l_{L}$ and $l_{R}$.}
		\State $f_{L} \gets \rho(l_{R})$
		\State $f_{R} \gets \rho(l_{R})$

		\State $f_{a} \gets (\emptyset \to \emptyset)$
		\Statex \Comment{Compute the combined action function $f_{a}$}
		\State $f_{a} \gets (\emptyset \to \emptyset)$
		\ForAll{$w_{R, \; I} \in \operatorname{Dom}(f_{R})$}
		\State $w_{R, \; F} \gets f_{R}(w_{R, \; I})$
		\ForAll{$w_{L, \; I} \in \operatorname{Dom}(f_{L})$}
		\If{$w_{L, \; I} = w_{R, \; F}$}
		\State $w_{L, \; F} \gets f_{L}(w_{L, \; I})$
		\State $f_{a} \gets f_{a} \cup f_{a}'$ where $f_{a}': \{w_{R, \; I}\} \to \{w_{L, \; F}\}$ such that $f_{a}'(w_{R, \; I}) = w_{L, \; F}$
		\EndIf
		\EndFor
		\EndFor
		\State \Return $f_{a}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\whendraft{
	\section{Example [\textbf{To do}]}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical justification}
\whendraft{
	\noindent\rule{\textwidth}{1mm}
	\textbf{To do:}
	\begin{enumerate}
		\item Proof that algorithm halts when it has all necessary elements and not before.
        \item Different name for `action function' ?
	\end{enumerate}
	\noindent\rule{\textwidth}{1mm}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preliminaries}
\whendraft{
\noindent\rule{\textwidth}{1mm}
\textbf{To do:}
\begin{enumerate}
    \item Pseudocode of word description.
    \item Pseudocode of simplified mathematical version of algorithm with use of $\epsilon$, and $\hat{A}$ instead of $\hat{A}/\sim$. - put in margin ?
    \item Footnote:
    Mathematically,
    \begin{enumerate}[(a)]
        \item we can use the set $\hat{A}$ of minimum actions to create new candidate elements in the iterations of our expansion step instead of the set $\hat{A}/\sim$ of distinct minimum actions.
        
        \item we can initialise the algorithm with $L = \{ \epsilon \}$, $\mathcal{T} = \{f_{\epsilon}\}$, $\rho(\epsilon) = f_{\epsilon}$, and then go straight to the expansion step since the first iteration of the expansion step will check the actions $\hat{a} \circ \epsilon$ for all $\hat{a} \in \hat{A}$ and $\hat{a} \circ \epsilon = \hat{a}$ for all $\hat{a} \in \hat{A}$ by the definition of $\epsilon$.
    \end{enumerate}

    In practical terms,
    \begin{enumerate}[(a)]
        \item using the set $\hat{A}/\sim$ of distinct minimum actions reduces the number of candidates elements we need to check for distinctness in each iteration of the expansion step since $(\hat{a}_{1} \circ a) \sim (\hat{a}_{2} \circ a)$ if $\hat{a}_{1} \sim \hat{a}_{2}$;
        
        \item we already calculate the $f_{\hat{a}}$ for all $\hat{a} \in \hat{A}$ to get our set of distinct minimum actions $\hat{A}/\sim$, so it's natural to set $L \gets \hat{A}/\sim$, $\mathcal{T} \gets \{f_{\hat{a}}\}$ for all $\hat{a} \in \hat{A}/\sim$, and $\rho \gets (\hat{a} \mapsto f_{\hat{a}})$ for all $\hat{a} \in \hat{A}/\sim$.
    \end{enumerate}
    We also need to be a little careful with $\epsilon$ because, even though $\epsilon$ is always in $\hat{A}^{*}$ for mathematical reasons, if none of the agent's actions are equivalent to $\epsilon$, then we might not want to include it in our algebra of the transformations of the actions of the agent.
    \draftnote{blue}{awjdean}{what does this mean for the Cayley table? I think you'd have $\epsilon$ as an identity element, but there would be no identity elements as entries in the table other than in the row and column of $\epsilon$.}
\end{enumerate}
\noindent\rule{\textwidth}{1mm}
}




\paragraph{Algorithm description.}
Algorithm \ref{alg:GenerateEquivClasses} can be split into three parts: (1) the initialisation step, (2) the expansion step, and (3) the termination condition.

\textbf{Initialisation.}
We start by finding the distinct minimum actions in $\hat{A}$ by calculating their actions functions $f_{\hat{a}}: w \mapsto \hat{a} \ast w$ and checking if they are unique in $\mathcal{T}$.
We can then initialise our set $L$ of actions whose induced action functions (stored in $\mathcal{T}$) are unique as $L \gets \hat{A}/\sim$ of distinct minimum actions, we can initialise our set $\mathcal{T}$ of unique action functions as $\mathcal{T}\gets \{f_{\hat{a}}\}$ for all $\hat{a} \in \hat{A}/\sim$, and we can initialise our map $\rho$ that stores the correspondence between distinct actions in $L$ and their unique action functions in $\mathcal{T}$ as $\rho \gets (\hat{a} \mapsto f_{\hat{a}})$ for all $\hat{a} \in \hat{A}/\sim$.

\textbf{Expansion.}
In each iteration of the expansion step we attempt to expand the set $L$ of distinct actions by left composing minimum actions onto the distinct actions we've previously discovered to get new candidates for distinct actions: $a_{C} = \hat{a} \circ l$ for every $\hat{a} \in \hat{A}/\sim$ and for every $l \in L$.
These candidate are then checked for distinctness using the same process as for minimum actions: find the action function $f_{a_{C}}$ for the candidate $a_{C}$ and check if it is already in $\mathcal{T}$; if it's not, then store $a_{C}$, $f_{a_{C}}$ and the correspondence between them in $L$, $\mathcal{T}$, and $\rho$.
In reality, in every iteration of the expansion step we only need to create candidates using the actions in $L$ with the greatest length when expressed in terms of their unique sequence of minimum actions rather than creating candidates using every action in $L$; this is because if the largest actions in $L$ at the start of an expansion iteration have a length of $n$, then all elements with a length of less than $n$ have already been checked for distinctness due to the creation of candidates at each expansion iteration using a single minimum action and so increasing the length of candidates by one at each iteration.

\textbf{Termination.}
The algorithm halts when an expansion iteration produces no new distinct action functions.

\begin{algorithm}[H]
	\caption{
		Compute the action function for the combination $l_{L} \circ l_{R}$ of two actions by combining their action functions.
	}
	\hrulefill
	\begin{algorithmic}[1]
		\Procedure{ComputeCombinedActionFunction}{$l_{R}$, \; $l_{L}$, \; }
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithm \ref{alg:GenerateEquivClasses} halts}

\begin{proposition}
    Algorithm \ref{alg:GenerateEquivClasses} always halts for finite $W$.
\end{proposition}
\begin{proof}
    \textbf{$|L|$ increases monotonically.}
    During each expansion iteration, the set $L$ either grows or remains the same.
    So at each expansion iteration, with a new distinct action is discovered and added to $L$ or no new distinct actions are discovered and the algorithm halts.

    \textbf{Upper bound on $|L|$.}
    Since, for a world with $|W|$ world states there are at most $(|W| + 1)^(|W| + 1)$ distinct transformations $W^{\bot} \to W^{\bot}$, the set $L$ can have at most $(|W| + 1)^(|W| + 1)$ elements.

    \textbf{Halting.}
    If $L$ stops growing for one expansion iteration, then the algorithm halts.
    If $L = (|W| + 1)^(|W| + 1)$, then there are no more unique action functions and therefore no more distinct actions under $\sim$ and so  algorithm \ref{alg:GenerateEquivClasses} halts.
    $|L|$ increases monotonically, therefore either $|L|$ reaches $(|W| + 1)^(|W| + 1)$ and halts or the algorithm halts for another reason.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{When algorithm \ref{alg:GenerateEquivClasses} halts, $L \cong \hat{A}^{*}/\sim$}

\begin{proposition}
    When algorithm \ref{alg:GenerateEquivClasses} halts, the set $L$ contains all distinct actions under $\sim$ in $\hat{A}^{*}$ (i.e., there is an isomorphism $L \cong \hat{A}^{*}/\sim$ between the elements of $L$ and the elements of $\hat{A}^{*}/\sim$ upon termination).
\end{proposition}
\begin{proof}
    \textbf{Proof by contradiction.}
    Assume algorithm \ref{alg:GenerateEquivClasses} halts with a set $L$ of discovered distinct actions, but that there exists at least one distinct transformation that is not represented in $L$.

    Let $b$ be the shortest undiscovered distinct action.
    We can write $b$ as $b = \hat{a} \circ b'$ where $\hat{a} \in \hat{A}/\sim$ and $b' \in \hat{A}^{\ast}$.

    Since $b$ is the shortest undiscovered distinct action, either $b'$ must have been discovered and be represented in $L$ or $b'$ is not discovered and $b$ is not the shortest undiscovered distinct action, since $b'$ is shorter than $b$, which is a contradiction.

    Given that $b'$ is known and represented in $L$, algorithm \ref{alg:GenerateEquivClasses} will have left composed $b'$ with every distinct minimum action in $\hat{A}/\sim$, including $\hat{a}$.
    Therefore, algorithm \ref{alg:GenerateEquivClasses} must have discovered $\hat{a} \circ b' = a$, which is a contradiction.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Analysis of complexity}

Let $|W| = n$ (so $|W^{\bot}| = n+1$) and let $|\hat{A}/\sim| = m$.

In the worst case, algorithm \ref{alg:GenerateEquivClasses} must discover all $|W^{\bot}|^{|W^{\bot}|}$ functions $W^{\bot} \to W^{\bot}$.
The algorithm generates new candidate actions by composing discovered distinct actions in $L$ with distinct minimum actions in $\hat{A}/\sim$; in the worst case scenario that would mean $m (n+1)^{(n+1)}$ candidate elements to check.
Checking each candidate element costs at least $\mathcal{O}(n)$ time because the the action function for each candidate must be determined for each of the $|W^{\bot}|$ states.
Therefore, an estimate for the upper bound on the complexity of algorithm \ref{alg:GenerateEquivClasses} is
\begin{equation}
    \mathcal{O}(m \cdot (n+1)^{(n+1)} \cdot n)
\end{equation}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Minimum actions affect the algebra}
\whendraft{
	\begin{enumerate}
		\item Have a world $\mathscr{W}$ with loads of transformations, then have different agent actions (different labelling map).
	\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{3Algorithm/Old/main}